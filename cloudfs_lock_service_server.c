/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include "hashmap.h"
#include "cloudfs_lock_service.h"
#include "cloudfs_lock_service_svc.h"
#include <sys/syscall.h>
#include <time.h>
#include <errno.h>


void acquire_read(lock_item *li) {
	pthread_mutex_lock(&li->mutex);
	while (li->i < 0) {
		pthread_cond_wait(&li->cond, &li->mutex);
	}
	li->i = li->i + 1;
	pthread_mutex_unlock(&li->mutex);
}

void acquire_write(lock_item *li) {
	pthread_mutex_lock(&li->mutex);
	while (li->i != 0) {
		pthread_cond_wait(&li->cond, &li->mutex);
	}
	li->i = li->i - 1;
        pthread_mutex_unlock(&li->mutex);
}

void release_read(lock_item *li) {
	pthread_mutex_lock(&li->mutex);
	li->i = li->i - 1;
	if (li->i == 0) {
		pthread_cond_signal(&li->cond);
	}
	pthread_mutex_unlock(&li->mutex);
}

void release_write(lock_item *li) {
	pthread_mutex_lock(&li->mutex);
        li->i = 0;
        pthread_cond_broadcast(&li->cond);
        pthread_mutex_unlock(&li->mutex);
}

void print_log(long tid, type operation, long key, const char *msg) {
	int time_length;
	time_t rawtime;
	struct tm *timeinfo;
	char *time_str;

	time(&rawtime);
	timeinfo = localtime(&rawtime);
  	time_str = asctime(timeinfo);
  	time_length = strlen(time_str);
  	time_str[time_length-1] = ' '; // replace last \n with ' '
        printf("%s tid:%ld----type:%s----key:%ld %s\n",
			time_str, tid,
			operation == type.UNDEFINED ? "undefined" : (operation == type.RELEASE ? "release" : (operation == type.READ ? "read" : "write")),
			key, msg);
}

bool_t
acquire_1_svc(lock_params *argp, status *result, struct svc_req *rqstp)
{
	bool_t retval;
	keyname key_str;
	long key, tid;
	type operation;
	lock_item *lock;
	char start_msg[100];

	/*
	 * insert server code here
	 */
	memset(start_msg, 0, sizeof(start_msg));
	operation = argp->operation;
	tid = syscall(SYS_gettid);
	key_str = argp->key;
	sprintf(start_msg, "Receive key:%s addr:%p in acquire", key_str, key_str);
	print_log(tid, operation, 0, start_msg);

	if (operation == UNDEFINED) {
		*result = ERROR;
		return TRUE;
	}

	if (key_str == NULL || *key_str == 0) {
		*result = ERROR;
		return TRUE;
	}

	key = hashFunction(key_str, hash_map);

	pthread_mutex_lock(&mutex); // lock here
	lock = (lock_item *) hashmapGet(hash_map, key);

	if (lock == NULL) {
		print_log(tid, operation, key, "lock is new, create a new one..");
		lock = malloc(sizeof(lock_item));
		lock->i = 0;
		pthread_mutex_init(&lock->mutex, NULL);
		pthread_cond_init(&lock->cond, NULL);
		hashmapInsert(hash_map, lock, key);
		pthread_mutex_unlock(&mutex); // unlock here

		if (operation == READ) {
			acquire_read(lock);
			print_log(tid, operation, key, "grab read lock!");
		} else if (operation == WRITE) {
			acquire_write(lock);
			print_log(tid, operation, key, "grab write lock!");
		}
		*result = OK;
	} else {
		print_log(tid, operation, key, "lock exist..");
		pthread_mutex_unlock(&mutex); // or unlock here
		if (operation == READ) {
			acquire_read(lock);
			print_log(tid, operation, key, "grab read lock!");
		} else if (operation == WRITE) {
			acquire_write(lock);
			print_log(tid, operation, key, "grab write lock!");
		}
		*result = OK;
	}
	lock->operation = operation; // this is the next free operation for this key

	return TRUE;
}

bool_t
release_1_svc(lock_params *argp, status *result, struct svc_req *rqstp)
{
	bool_t retval;
	keyname key_str;
	long key, tid;
	type operation;
	lock_item *lock;
	char start_msg[100];

        /*
         * insert server code here
         */
        memset(start_msg, 0, sizeof(start_msg));
        operation = argp->operation;
        tid = syscall(SYS_gettid);
        key_str = argp->key;
        sprintf(start_msg, "Receive key:%s addr:%p in release", key_str, key_str);
        print_log(tid, operation, 0, start_msg);

	if (operation == UNDEFINED) {
		*result = ERROR;
		return TRUE;
	}

	if (key_str == NULL || *key_str == 0) {
                *result = ERROR;
                return TRUE;
        }

	key = hashFunction(key_str, hash_map);
	tid = syscall(SYS_gettid);

	pthread_mutex_lock(&mutex); // lock here
	lock = (lock_item *) hashmapGet(hash_map, key);
	pthread_mutex_unlock(&mutex);

	if (lock == NULL) {
		*result = ERROR;
        	return TRUE;
	}

	if (lock->operation == READ) {
		release_read(lock);
	} else if (lock->operation == WRITE) {
		release_write(lock);
	}
	memset(start_msg, 0, sizeof(start_msg));
	sprintf(start_msg, "<-----unlock key:%ld----->", key);
	print_log(tid, operation, key, start_msg);
	*result = OK;

	return TRUE;
}

int
lockserviceprog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
